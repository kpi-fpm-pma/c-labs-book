---
redirect_from:
  - "/outro/appendixd"
title: |-
  Додаток Г. Алгоритми сортування та пошуку
pagenum: 36
prev_page:
  url: /outro/appendixC.html
next_page:
  url: /outro/bibliography.html
suffix: .md
search: x ai right d n left ldots le m b al frac j aj ar dk k aia ge r

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div id="page-info"><div id="page-title">Додаток Г. Алгоритми сортування та пошуку</div>
</div>
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="&#1044;&#1086;&#1076;&#1072;&#1090;&#1086;&#1082;-&#1043;.-&#1040;&#1083;&#1075;&#1086;&#1088;&#1080;&#1090;&#1084;&#1080;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1090;&#1072;-&#1087;&#1086;&#1096;&#1091;&#1082;&#1091;">&#1044;&#1086;&#1076;&#1072;&#1090;&#1086;&#1082; &#1043;. &#1040;&#1083;&#1075;&#1086;&#1088;&#1080;&#1090;&#1084;&#1080; &#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103; &#1090;&#1072; &#1087;&#1086;&#1096;&#1091;&#1082;&#1091;<a class="anchor-link" href="#&#1044;&#1086;&#1076;&#1072;&#1090;&#1086;&#1082;-&#1043;.-&#1040;&#1083;&#1075;&#1086;&#1088;&#1080;&#1090;&#1084;&#1080;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1090;&#1072;-&#1087;&#1086;&#1096;&#1091;&#1082;&#1091;"> </a></h1><h2 id="&#1052;&#1077;&#1090;&#1086;&#1076;&#1080;&#1095;&#1085;&#1110;-&#1074;&#1082;&#1072;&#1079;&#1110;&#1074;&#1082;&#1080;">&#1052;&#1077;&#1090;&#1086;&#1076;&#1080;&#1095;&#1085;&#1110; &#1074;&#1082;&#1072;&#1079;&#1110;&#1074;&#1082;&#1080;<a class="anchor-link" href="#&#1052;&#1077;&#1090;&#1086;&#1076;&#1080;&#1095;&#1085;&#1110;-&#1074;&#1082;&#1072;&#1079;&#1110;&#1074;&#1082;&#1080;"> </a></h2><p>Алгоритми сортування та пошуку наведено нижче. У наведених алгоритмах масиви упорядковують за зростанням.</p>
<h2 id="&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1086;&#1073;&#1084;&#1110;&#1085;&#1086;&#1084;">&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103; &#1086;&#1073;&#1084;&#1110;&#1085;&#1086;&#1084;<a class="anchor-link" href="#&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1086;&#1073;&#1084;&#1110;&#1085;&#1086;&#1084;"> </a></h2><p>Послідовно порівнюється елемент $a_0$ із кожним наступним $a_i$. Якщо $a_i &lt; a_0$, то ці два елементи міняють місцями. Таким чином найменший елемент виявляється на своєму місці на початку масиву. Потім цей метод застосовують до елемента $a_1$ і т.д.</p>
<h2 id="&#1064;&#1077;&#1081;&#1082;&#1077;&#1088;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;">&#1064;&#1077;&#1081;&#1082;&#1077;&#1088;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;<a class="anchor-link" href="#&#1064;&#1077;&#1081;&#1082;&#1077;&#1088;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;"> </a></h2><p>У цьому методі проходи масиву виконують по черзі зліва направо, а потім справа наліво. Послідовно порівнюють пари сусідніх елементів ($a_0$ і $a_1$, $a_1$ і $a_2$, і т.д.) і, якщо треба, переставляють місцями. Запам’ятовують індекс останнього елемента, що переставляється (<code>right</code>). Далі масив проглядають справа наліво, починаючи з індекса <code>right</code>. У цьому проході також виконують порівняння сусідніх елементів і їх перестановлення. Запам’ятовують індекс останнього елемента, що переставляється (<code>left</code>). Далі знову виконують прохід зліва направо від індекса <code>left</code> до індекса <code>right</code>, і т.д.</p>
<h2 id="&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1064;&#1077;&#1083;&#1083;&#1072;">&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103; &#1064;&#1077;&#1083;&#1083;&#1072;<a class="anchor-link" href="#&#1057;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1064;&#1077;&#1083;&#1083;&#1072;"> </a></h2><p>Вибирають інтервал $d$ між порівнюваними елементами, і виконують сортування масиву методом «бульбашки», але з кроком $d$. Після етапу сортування масиву з обраним інтервалом інтервал зменшують і знову виконують сортування масиву методом «бульбашки». Рекомендована послідовність значень $d$: $1, 3, 7, 15, 31, \ldots,$ тобто $d_k=\frac{d_{k-1}-1}{2}$.</p>
<p>Максимальне значення $d$ не повинно перевищувати довжину масиву. У цьому алгоритмі на першому проході порівнюють і, якщо треба, переставляють елементи, що далеко стоять, а на останньому проході — сусідні.</p>
<h2 id="&#1063;&#1086;&#1074;&#1085;&#1080;&#1082;&#1086;&#1074;&#1077;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;">&#1063;&#1086;&#1074;&#1085;&#1080;&#1082;&#1086;&#1074;&#1077; &#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;<a class="anchor-link" href="#&#1063;&#1086;&#1074;&#1085;&#1080;&#1082;&#1086;&#1074;&#1077;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;"> </a></h2><p>Послідовно порівнюють пари сусідніх елементів $a_0$ і $a_1$, $a_1$ і $a_2$, і т.д., і якщо $a_i&gt;a_{i+1}$, то елемент $a_{i+1}$ просувають уліво наскільки можливо. Його порівнюють зі своїм попередником і, якщо він менший від попередника, виконують обмін, і починається чергове порівняння. Коли елемент, який пересувають уліво, зустрічає меншого попередника, то процес пересування вліво припиняється, і поновлюється перегляд масиву зліва направо з позиції, із якої виконувався обмін під час просування зліва направо.</p>
<h2 id="&#1064;&#1074;&#1080;&#1076;&#1082;&#1077;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-(&#1084;&#1077;&#1090;&#1086;&#1076;-&#1061;&#1086;&#1072;&#1088;&#1072;)">&#1064;&#1074;&#1080;&#1076;&#1082;&#1077; &#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103; (&#1084;&#1077;&#1090;&#1086;&#1076; &#1061;&#1086;&#1072;&#1088;&#1072;)<a class="anchor-link" href="#&#1064;&#1074;&#1080;&#1076;&#1082;&#1077;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-(&#1084;&#1077;&#1090;&#1086;&#1076;-&#1061;&#1086;&#1072;&#1088;&#1072;)"> </a></h2><p>Ідея методу полягає в тому, що спочатку переставляють елементи, які знаходяться один від одного на великих відстанях. Вибирають елемент масиву (наприклад, центральний), який розбиває масив на дві підмножини. Нехай значення цього елемента — $x$. Елементи масиву переставляють так, щоб зліва від $x$ знаходилися елементи $a_i\le x$, а праворуч — $a_i\ge x$. Після перестановок елемент $x$ знаходитиметься на своєму місці. Далі алгоритм поділу масиву на ліву й праву частини застосовують до лівої, а потім до правої частин, потім до частин частин, і так доти, доки кожна з частин не складатиметься з єдиного елемента. У цьому сортуванні використовують рекурсію.</p>
<p>Для поділу елементів масиву, починаючи з елемента з індексом <code>left</code> до елемента з індексом <code>right</code>, відносно «центрального» елемента $x$, уводять два індекси <code>i = left</code>, <code>j = right</code>. Елементи проглядають зліва направо доти, доки не виявиться елемент , потім масив проглядають справа наліво, поки не виявиться елемент $a_j \le x$. Після цього елементи міняють місцями. Далі процес перегляду й перестановки повторюють доти, доки не стане $i &gt; j$.</p>
<h3 id="&#1050;&#1086;&#1084;&#1073;&#1110;&#1085;&#1086;&#1074;&#1072;&#1085;&#1080;&#1081;-&#1084;&#1077;&#1090;&#1086;&#1076;-&#1096;&#1074;&#1080;&#1076;&#1082;&#1086;&#1075;&#1086;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1079;-&#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1084;-&#171;&#1073;&#1091;&#1083;&#1100;&#1073;&#1072;&#1096;&#1082;&#1080;&#187;">&#1050;&#1086;&#1084;&#1073;&#1110;&#1085;&#1086;&#1074;&#1072;&#1085;&#1080;&#1081; &#1084;&#1077;&#1090;&#1086;&#1076; &#1096;&#1074;&#1080;&#1076;&#1082;&#1086;&#1075;&#1086; &#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103; &#1079; &#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1084; &#171;&#1073;&#1091;&#1083;&#1100;&#1073;&#1072;&#1096;&#1082;&#1080;&#187;<a class="anchor-link" href="#&#1050;&#1086;&#1084;&#1073;&#1110;&#1085;&#1086;&#1074;&#1072;&#1085;&#1080;&#1081;-&#1084;&#1077;&#1090;&#1086;&#1076;-&#1096;&#1074;&#1080;&#1076;&#1082;&#1086;&#1075;&#1086;-&#1089;&#1086;&#1088;&#1090;&#1091;&#1074;&#1072;&#1085;&#1085;&#1103;-&#1079;-&#1084;&#1077;&#1090;&#1086;&#1076;&#1086;&#1084;-&#171;&#1073;&#1091;&#1083;&#1100;&#1073;&#1072;&#1096;&#1082;&#1080;&#187;"> </a></h3><p>У цьому методі рекурсивний алгоритм поділу масиву швидкого сортування застосовують тільки до послідовностей масиву, довжина яких не менша за певний розмір $m$($m \le n$, де $n$ — розмірність масиву). Для сортування коротких послідовностей використовують метод «бульбашки».</p>
<h2 id="&#1051;&#1110;&#1085;&#1110;&#1081;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;">&#1051;&#1110;&#1085;&#1110;&#1081;&#1085;&#1072; &#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;<a class="anchor-link" href="#&#1051;&#1110;&#1085;&#1110;&#1081;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;"> </a></h2><p>Елементи масиву ділять на послідовність уже впорядкованих елементів $a_0, a_1,\ldots,a_{i-1}$ і послідовність ще не впорядкованих елементів $a_i, a_{i+1}, \ldots, a_{n-1}$, де $n$ — розмірність масиву. У кожному проході з невпорядкованої послідовності витягують елемент  (у першому проході $i = 1$) і вставляють в упорядковану послідовність з $i$ елементів без порушення впорядкованості в ній. Цей алгоритм повторюють для $i = 2,3,\ldots,n-1$. Алгоритм вставлення $a_i$ в упорядковану послідовність з $i$ елементів полягає в просуванні вставлюваного елемента в початок послідовності, порівнюючи його з $a_{i-1}, a_{i-2}$ і т.д. Просування закінчують на елементі $a_j \le a_i$ або у випадку проходження всієї послідовності.</p>
<h2 id="&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;">&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1072; &#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;<a class="anchor-link" href="#&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;"> </a></h2><p>У цьому методі, на відміну від лінійної вставки, для відшукання місця для вставлення елемента $a_i$ в упорядковану послідовність використовують алгоритм <em>бінарного пошуку</em>, за якого елемент $a_i$ порівнюють із середнім елементом упорядкованої послідовності, а потім процес ділення навпіл триває доти, доки не буде знайдено точки вставлення.</p>
<h2 id="&#1062;&#1077;&#1085;&#1090;&#1088;&#1086;&#1074;&#1072;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;">&#1062;&#1077;&#1085;&#1090;&#1088;&#1086;&#1074;&#1072;&#1085;&#1072; &#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;<a class="anchor-link" href="#&#1062;&#1077;&#1085;&#1090;&#1088;&#1086;&#1074;&#1072;&#1085;&#1072;-&#1074;&#1089;&#1090;&#1072;&#1074;&#1082;&#1072;"> </a></h2><p>Алгоритм використовує додатковий робочий масив. У позицію, розташовану в центрі робочого масиву, поміщують елемент $a_0$. Він буде медіаною. Зліва від медіани потрібно розташувати всі елементи, менші від неї, а праворуч — більші чи рівні. Із сортованого масиву послідовно вибирають елемент, порівнюють його з медіаною та вставляють без порушення впорядкованості в ліву чи праву частини масиву. Якщо область пам’яті, виділену для однієї з частин, буде вичерпано, усі елементи робочого масиву зсувають у протилежному напрямку, і значення медіани змінюють. У кінці алгоритму впорядковані елементи повинно бути скопійовано у вихідний масив.</p>
<h2 id="&#1052;&#1077;&#1090;&#1086;&#1076;-&#1092;&#1086;&#1085;-&#1053;&#1086;&#1081;&#1084;&#1072;&#1085;&#1072;">&#1052;&#1077;&#1090;&#1086;&#1076; &#1092;&#1086;&#1085; &#1053;&#1086;&#1081;&#1084;&#1072;&#1085;&#1072;<a class="anchor-link" href="#&#1052;&#1077;&#1090;&#1086;&#1076;-&#1092;&#1086;&#1085;-&#1053;&#1086;&#1081;&#1084;&#1072;&#1085;&#1072;"> </a></h2><p>Ідея методу полягає в тому, щоб упорядкувати пари сусідніх елементів масиву ($a_0$ і $a_1$, $a_2$ і $a_3$ і т.д.) і перенести їх у допоміжний масив <code>b</code>. Потім потрібно взяти по дві сусідні пари з <code>b</code> і, зливши їх в упорядковані четвірки, знову записати в <code>а</code>. Потім кожні дві четвірки з <code>b</code> злити в упорядковані вісімки й переписати в <code>а</code>, і т.д. Упорядкований масив повинен виявитися в масиві <code>а</code>.</p>
<h2 id="&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1080;&#1081;-&#1087;&#1086;&#1096;&#1091;&#1082;">&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1080;&#1081; &#1087;&#1086;&#1096;&#1091;&#1082;<a class="anchor-link" href="#&#1041;&#1110;&#1085;&#1072;&#1088;&#1085;&#1080;&#1081;-&#1087;&#1086;&#1096;&#1091;&#1082;"> </a></h2><p>Алгоритм застосовують до впорядкованого масиву, у якому потрібно знайти номер елемента з заданим значенням <code>x</code>. Спочатку <code>х</code> порівнюють із середнім елементом масиву. Якщо збіг знайдено, то повертають індекс середнього елемента, інакше визначають, у якій половині масиву потрібно виконувати пошук, застосовуючи до неї рекурсивно алгоритм бінарного пошуку.</p>
<h2 id="&#1030;&#1085;&#1090;&#1077;&#1088;&#1087;&#1086;&#1083;&#1103;&#1094;&#1110;&#1081;&#1085;&#1080;&#1081;-&#1087;&#1086;&#1096;&#1091;&#1082;">&#1030;&#1085;&#1090;&#1077;&#1088;&#1087;&#1086;&#1083;&#1103;&#1094;&#1110;&#1081;&#1085;&#1080;&#1081; &#1087;&#1086;&#1096;&#1091;&#1082;<a class="anchor-link" href="#&#1030;&#1085;&#1090;&#1077;&#1088;&#1087;&#1086;&#1083;&#1103;&#1094;&#1110;&#1081;&#1085;&#1080;&#1081;-&#1087;&#1086;&#1096;&#1091;&#1082;"> </a></h2><p>Алгоритм застосовують до впорядкованого масиву, у якому потрібно знайти номер елемента з заданим значенням <code>x</code>. Якщо відомо, що <code>х</code> знаходиться між елементами $a_l$ і $a_r$, номер чергового елемента для порівняння обчислюють за формулою $m = 1 + (r-1)\frac{x - a_l}{a_r - a_l}$. Якщо збіг знайдено, то повертають індекс елемента <code>m</code>, інакше визначають, у якій частині масиву потрібно виконувати пошук, застосовуючи до неї рекурсивно алгоритм інтерполяційного пошуку.</p>

</div>
</div>
</div>
</div>

 


    </main>
    