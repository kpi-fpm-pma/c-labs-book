

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Теоретичні відомості &#8212; Основи програмування &lt;br/&gt; мовою С</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-dropdown.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://gasperpaul.github.io/c-labs-book/content/lab5/theory.html" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Контрольні питання" href="questions.html" />
    <link rel="prev" title="Вступ" href="intro.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">


<!-- Opengraph tags -->
<meta property="og:url"         content="https://gasperpaul.github.io/c-labs-book/content/lab5/theory.html" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Теоретичні відомості" />
<meta property="og:description" content="Теоретичні відомості  Програміст під час написання програми мовою С може створювати дані п’ятьох типів:  структуру (structure);  об’єднання (union);  перерахову" />
<meta property="og:image"       content="https://gasperpaul.github.io/c-labs-book/_static/logo.png" />

<meta name="twitter:card" content="summary" />


  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Основи програмування <br/> мовою С</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/intro.html">
   Вступ
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №1
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab1/intro.html">
   Базові типи даних, уведення-виведення, бітові операції, операції зсуву
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №2
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab2/intro.html">
   Одновимірні й двовимірні масиви
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №3
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab3/intro.html">
   Опрацювання символьних даних
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №4
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab4/intro.html">
   Указівники, функції, рекурсія
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №5
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="reference internal" href="intro.html">
   Типи даних, визначені користувачем
  </a>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Теоретичні відомості
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="questions.html">
     Питання для самоперевірки
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="problems.html">
     Завдання
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №6
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab6/intro.html">
   Динамічні масиви
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №7
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab7/intro.html">
   Однозв'язні списки
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Лабораторна робота №8
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../lab8/intro.html">
   Робота з бінарними й текстовими файлами
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Додатки
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../outro/appendixA.html">
   Додаток А. Рекомендації зі створення інтерфейсу
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../outro/appendixB.html">
   Додаток Б. Титульний лист лабораторної роботи
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../outro/appendixC.html">
   Додаток В. Приклад програмування бітових операцій і операцій зсуву
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../outro/appendixD.html">
   Додаток Г. Алгоритми сортування та пошуку
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../outro/bibliography.html">
   Рекомендована література
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  <a href="mailto:vikvikgrom@gmail.com">Громова В.В.</a>, 2020
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/content/lab5/theory.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/GasperPaul/c-labs-book/master?urlpath=lab/tree/content/lab5/theory.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/GasperPaul/c-labs-book/blob/master/content/lab5/theory.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   Структура
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   Доступ до окремих бітів
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   Об’єднання
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id5">
   Перерахування
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   Перейменування типів
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="id1">
<h1>Теоретичні відомості<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Програміст під час написання програми мовою С може створювати дані п’ятьох типів:</p>
<ul class="simple">
<li><p>структуру (structure);</p></li>
<li><p>об’єднання (union);</p></li>
<li><p>перераховуваний тип (enumeration);</p></li>
<li><p>поля бітів (bit fields);</p></li>
<li><p>нове ім’я (псевдонім) для вже існуючого типу (за допомогою оператора <code class="docutils literal notranslate"><span class="pre">typedef</span></code>).</p></li>
</ul>
<div class="section" id="id2">
<h2>Структура<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>У розробленні програм важливим є вибір ефективного способу подання інформації. У багатьох випадках недостатньо оголосити просту змінну чи масив: потрібна гнучкіша форма подання. Таким елементом може бути <em>структура</em>, яка дає змогу включати в себе дані різних типів, а також інші структури. Структуру задають у мові С за допомогою ключового слова <code class="docutils literal notranslate"><span class="pre">struct</span></code>, за яким слідує її ім’я.</p>
<p>Структура об’єднує декілька змінних, можливо, різного типу. Змінні, об’єднані структурою, називають її <em>членами</em>, <em>елементами</em> чи <em>полями</em>.
Приклад визначення структури:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">group</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">scholarship</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Оголошення структури є оператором, тому після нього ставлять крапку з комою. При цьому потрібно розуміти, що на даному етапі жодної змінної не оголошено, оскільки не відбулося виділення пам’яті під змінні. У прикладі під іменем <em><code class="docutils literal notranslate"><span class="pre">student</span></code></em> задано вид структури, інакше кажучи, її <em>шаблон</em>, і визначено новий тип <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">student</span></code>. Щоб оголосити конкретні змінні типу <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">student</span></code>, можна записати:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">student</span> <span class="n">stud1</span><span class="p">,</span> <span class="n">stud2</span><span class="p">;</span>
</pre></div>
</div>
<p>Тепер оголошено дві змінні — <code class="docutils literal notranslate"><span class="pre">stud1</span></code> і <code class="docutils literal notranslate"><span class="pre">stud2</span></code>. Компілятор автоматично виділить під них безперервну ділянку пам’яті комп’ютера, що дає можливість працювати зі структурою як із єдиним об’єктом даних, який має в даному прикладі чотири поля: <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">year</span></code>, <code class="docutils literal notranslate"><span class="pre">group</span></code>, <code class="docutils literal notranslate"><span class="pre">scholarship</span></code>. Створення шаблона структури й оголошення змінних можна здійснювати й в одному операторі:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">student</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">group</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">scholarship</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stud1</span><span class="p">,</span> <span class="n">stud2</span><span class="p">;</span>
</pre></div>
</div>
<p>У цьому випадку одночасно задається структура з іменем student та оголошуються змінні <code class="docutils literal notranslate"><span class="pre">stud1</span></code> і <code class="docutils literal notranslate"><span class="pre">stud2</span></code>.</p>
<p>Доступ до конкретного елемента (поля) структури здійснюють за допомогою операції <code class="docutils literal notranslate"><span class="pre">.</span></code> («крапка», dot), наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">strcpy</span><span class="p">(</span><span class="n">stud1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;Кузина А. А.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Якщо потрібно надрукувати вміст третього поля змінної <code class="docutils literal notranslate"><span class="pre">stud2</span></code> структури <code class="docutils literal notranslate"><span class="pre">student</span></code>, то треба записати:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">stud2</span><span class="p">.</span><span class="n">group</span><span class="p">);</span>
</pre></div>
</div>
<p>Структури, як і змінні інших типів, можна об’єднувати в масиви структур. Щоб оголосити масив структур, потрібно спочатку задати шаблон структури, а потім оголосити сам масив:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">student</span> <span class="n">stud1year</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
</pre></div>
</div>
<p>Цей оператор створить у пам’яті 200 змінних типу структури з шаблоном <code class="docutils literal notranslate"><span class="pre">student</span></code> та іменами <code class="docutils literal notranslate"><span class="pre">stud1year[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">stud1year[1]</span></code> і т.д. Для доступу до поля <code class="docutils literal notranslate"><span class="pre">year</span></code>, наприклад, 35-го елемента масиву потрібно використати <code class="docutils literal notranslate"><span class="pre">stud1year[34].year</span></code>.</p>
<p>Якщо оголошено дві змінні типу структури з одним шаблоном, можна виконувати присвоювання: <code class="docutils literal notranslate"><span class="pre">stud1</span> <span class="pre">=</span> <span class="pre">stud2</span></code>. При цьому відбудеться побітове копіювання кожного поля однієї змінної у відповідне поле іншої. Не можна використовувати операцію присвоювання змінних типу структури, шаблони яких описано під різними іменами, нехай навіть зовсім ідентично. Тим не менше, у такому випадку можливе присвоювання для окремих полів однакового типу.</p>
<p>Змінна типу структури може бути глобальною, локальною змінною та формальним параметром. Структуру чи її поле можна використовувати як параметр функції, наприклад, <code class="docutils literal notranslate"><span class="pre">func1(right.a)</span></code> або <code class="docutils literal notranslate"><span class="pre">func2(&amp;left.b)</span></code>. Варто зауважити, що <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> ставлять перед іменем структури, а не перед іменем поля.</p>
<p>Як формальний параметр можна передати за значенням усю структуру. Також можна створити вказівник на структуру й передавати аргумент типу структури за посиланням. Оголосити вказівник на структуру можна так:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">stru</span><span class="o">*</span> <span class="n">adr_pointer</span><span class="p">;</span>
</pre></div>
</div>
<p>де <code class="docutils literal notranslate"><span class="pre">adr_pointer</span></code> — змінна-вказівник на структуру <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">stru</span></code>.</p>
<p>Якщо структуру передають за значенням, то всі поля структури заносять у стек. Якщо структура проста й містить мало елементів, то це не так істотно. Якщо ж структура як своє поле містить масив, то стек може переповнитися. Натомість, у випадку передачі за посиланням у стек заносять тільки адресу структури, її копіювання не відбувається. Додатково з’являється можливість змінювати вміст полів структури.</p>
<p>Розгляньмо відповідний приклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">complex</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">complex</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">;</span>
</pre></div>
</div>
<p>У цьому прикладі вказівнику а присвоюється адреса змінної <code class="docutils literal notranslate"><span class="pre">с1</span></code>. Одержати значення поля <code class="docutils literal notranslate"><span class="pre">х</span></code> змінної <code class="docutils literal notranslate"><span class="pre">с1</span></code> можна так: <code class="docutils literal notranslate"><span class="pre">(*a).x</span></code>.</p>
<p>Використання вказівників на структуру зустрічається досить часто, наприклад, у програмуванні завдань зі створення й опрацювання динамічних зв’язаних структур даних (черги, стеки, дерева тощо). Тому, крім способу одержати значення поля структури, використовуючи <code class="docutils literal notranslate"><span class="pre">(*a).x</span></code>, можна використовувати інший спосіб — використовуючи спеціальну операцію мови С <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> («стрілка», arrow).</p>
<p>Операцію «стрілка» вживають замість операції «крапка», коли потрібно використати значення поля структури з застосуванням змінної вказівника. Тоді, замість <code class="docutils literal notranslate"><span class="pre">(*a).x</span></code> можна використовувати <code class="docutils literal notranslate"><span class="pre">a-&gt;x</span></code>. Цей спосіб застосовують найчастіше.</p>
<p>Як поля структури можна використовувати масиви, структури й масиви структур, наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">addr</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">city</span><span class="p">[</span><span class="mi">34</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">street</span><span class="p">[</span><span class="mi">76</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">house</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fulladdr</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">addr</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">room</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
<span class="p">}</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
<p>де <code class="docutils literal notranslate"><span class="pre">addr</span></code> — шаблон структури, визначений перед оголошенням структури <code class="docutils literal notranslate"><span class="pre">fulladdr</span></code> та оголошенням змінної а типу структури <code class="docutils literal notranslate"><span class="pre">fulladdr</span></code>. Для присвоєння значення полю <code class="docutils literal notranslate"><span class="pre">house</span></code> структури <code class="docutils literal notranslate"><span class="pre">address</span></code> змінної а потрібно використати <code class="docutils literal notranslate"><span class="pre">a.adress.house</span> <span class="pre">=</span> <span class="pre">234</span></code>.</p>
</div>
<div class="section" id="id3">
<h2>Доступ до окремих бітів<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>На відміну від багатьох інших мов програмування, мова С забезпечує доступ до одного чи декількох бітів у байті чи слові. У конкретних задачах часто буває потрібно, щоб деяка змінна набувала тільки двох значень. Для цього достатньо використовувати тільки один біт пам’яті. За своїм змістовним сенсом така змінна є деякою ознакою (прапорцем).</p>
<p>Один із методів, убудованих у мову C, який дає змогу одержати доступ до біта, — це поля бітів. <em>Поля бітів</em> — це спеціальний тип членів структури, у якому визначено, зі скількох бітів складається кожне поле. Основна форма оголошення подібної структури така:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>struct &lt;ім’я_структури&gt;
{
    &lt;тип&gt; &lt;ім’я1&gt; : &lt;довжина в бітах&gt;;
    &lt;тип&gt; &lt;ім’я2&gt; : &lt;довжина в бітах&gt;;
    ...
    &lt;тип&gt; &lt;ім’яN&gt; : &lt;довжина в бітах&gt;;
};
</pre></div>
</div>
<p>де</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;тип&gt;</span></code> може бути одним із таких: <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span></code>, <code class="docutils literal notranslate"><span class="pre">signed</span></code>;</p></li>
<li><p>будь-яке з <code class="docutils literal notranslate"><span class="pre">&lt;імен&gt;</span></code> може бути пропущено, і тоді відповідна кількість бітів не використується (пропускається).</p></li>
</ul>
<p>Довжина структури завжди кратна 8. Так, якщо вказати</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">onebit</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">one_bit</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">obj</span><span class="p">;</span>
</pre></div>
</div>
<p>то для змінної <code class="docutils literal notranslate"><span class="pre">obj</span></code> буде виділено 8 бітів, але використовуватиметься тільки перший. У структурі може бути змішано звичайні змінні та поля бітів.</p>
</div>
<div class="section" id="id4">
<h2>Об’єднання<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>У мові С визначено ще один тип для розміщення в пам’яті декількох змінних різного типу — <em>об’єднання</em>. Цей засіб дає можливість зберігати в окремі моменти часу в одному й тому самому місці пам’яті дані різних типів. Об’єднання дають змогу працювати в одній і тій самій області пам’яті з даними різного вигляду, не вносячи до програми інформації, залежної від машини.</p>
<p>Об’єднання описують так само, як і структури, але замість ключового слова <code class="docutils literal notranslate"><span class="pre">struct</span></code> використовують ключове слово <code class="docutils literal notranslate"><span class="pre">union</span></code>. Як і для структур, можна визначити шаблон об’єднання з іменем типу й задати в цьому ж операторі одну чи декілька змінних об’єднання. Або ж опис змінних можна відокремити від визначення шаблону.</p>
<p>Розгляньмо приклад шаблону об’єднання з іменем типу <code class="docutils literal notranslate"><span class="pre">u</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">u</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">int</span> <span class="n">l</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Це оголошення задає шаблон об’єднання. Можна оголосити змінні:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">u</span> <span class="n">alfa</span><span class="p">,</span> <span class="n">beta</span><span class="p">;</span>
</pre></div>
</div>
<p>На відміну від структури, для змінної типу union місця в пам’яті виділяється рівно стільки, скільки потрібно полю об’єднання, що має найбільший розмір у байтах. У наведеному вище прикладі під змінну <code class="docutils literal notranslate"><span class="pre">alfa</span></code> буде виділено 4 байти пам’яті, оскільки поле i вимагає 2 байти, поле <code class="docutils literal notranslate"><span class="pre">ch</span></code> — 1 байт, поле <code class="docutils literal notranslate"><span class="pre">l</span></code> — 4 байти. Усі змінні розташовуватимуться в тому ж місці пам’яті. Програміст повинен самостійно стежити за типом даних, який записується в об’єднання в даний момент.</p>
<p>Синтаксис використання полів об’єднання такий самий, як і для структури, наприклад, <code class="docutils literal notranslate"><span class="pre">u.ch</span> <span class="pre">=</span> <span class="pre">'N'</span></code>. Для об’єднання також дозволено операцію <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, якщо звернення до об’єднання здійснюють за допомогою вказівника. Для змінних типу об’єднання також можна використовувати операції взяття адреси та одержання елемента через указівник.</p>
</div>
<div class="section" id="id5">
<h2>Перерахування<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p><em>Перерахування</em> — це конструйований тип даних, під час опису якого задають ім’я типу даних і значення, яких можуть набувати змінні цього типу.</p>
<p>Опис перерахованого типу даних здійснюють оператором виду:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>enum &lt;ім’я_типу&gt; {&lt;список_значень&gt;} &lt;список змінних&gt;;
</pre></div>
</div>
<p>де</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;ім’я_типу&gt;</span></code> задають ідентифікатором С на розсуд програміста;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;список_значень&gt;</span></code> задають у вигляді: <code class="docutils literal notranslate"><span class="pre">&lt;елемент1&gt;,</span> <span class="pre">&lt;елемент2&gt;,</span> <span class="pre">...,</span> <span class="pre">&lt;елементN&gt;</span></code>, де будь-який із елементів є або <code class="docutils literal notranslate"><span class="pre">&lt;ім’я&gt;</span></code>, або <code class="docutils literal notranslate"><span class="pre">&lt;ім’я&gt;</span> <span class="pre">=</span> <span class="pre">&lt;константний_вираз&gt;</span></code>. Як <code class="docutils literal notranslate"><span class="pre">&lt;ім’я&gt;</span></code> використовують ідентифікатор мовою С;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;список_змінних&gt;</span></code> — імена змінних типу перерахування, відокремлені один від одного комами.</p></li>
</ul>
<p>Семантично опис перерахування задає ім’я типу, визначає іменовані константи та імена змінних, які можуть набувати значень іменованих констант. Значення кожної іменованої константи зі списку значень є ціле число. Вирази з константами, якщо їх використовують, повинні бути цілими та можуть бути від’ємними. Якщо вирази з константами відсутні, то за замовчуванням першому імені списку значень відповідає 0, другому — 1 і т.д.</p>
<p>Використання в програмі іменованої константи рівнозначно використанню її значення. Явна ініціалізація іменованої константи константним виразом перевизначає послідовність значень, заданих за замовчуванням. Ім’я, наступне за перевизначеним іменем, набуває значення, збільшеного на 1, якщо тільки його значення не задано явно іншою величиною.</p>
<p>Приклад визначення перерахованого типу і змінної даного типу:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">season</span> <span class="p">{</span><span class="n">win</span><span class="p">,</span> <span class="n">spr</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">aut</span><span class="p">};</span>
<span class="k">enum</span> <span class="n">season</span> <span class="n">s</span><span class="p">;</span>
</pre></div>
</div>
<p>Ключем до розуміння сутності перерахованого типу є те, що кожне з імен <code class="docutils literal notranslate"><span class="pre">win</span></code>, <code class="docutils literal notranslate"><span class="pre">spr</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">aut</span></code> є цілою величиною. Якщо ці величини не визначено інакше, то за замовчуванням вони дорівнюють 0, 1, 2 і 3, відповідно.</p>
<p>Оператор <code class="docutils literal notranslate"><span class="pre">printf(&quot;%d%d&quot;,</span> <span class="pre">win,</span> <span class="pre">aut);</span></code> видасть на екран числа <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">3</span></code>. Під час оголошення типу можна одному або декільком символам привласнити інші значення, наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">value</span> <span class="p">{</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span><span class="p">,</span> <span class="n">ten</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">twenty</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">next</span><span class="p">};</span>
</pre></div>
</div>
<p>Якщо тепер надрукувати значення <code class="docutils literal notranslate"><span class="pre">printf(&quot;%d%d%d%d%d\n&quot;,</span> <span class="pre">one,</span> <span class="pre">two,</span> <span class="pre">ten,</span> <span class="pre">twenty,</span> <span class="pre">next);</span></code>, то на екрані з’являться числа <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">10</span> <span class="pre">20</span> <span class="pre">21</span></code>, тобто кожний наступний символ збільшується на 1 порівняно з попереднім, якщо немає іншого присвоювання.</p>
<p>Список значень може містити повторювані значення імен, але самі імена повинні бути різні. Список змінних в описі перерахованого типу можна опустити. У цьому випадку опис задає лише тип перерахування, що має задане ім’я та список допустимих значень. Змінні в цьому випадку повинно бути описано за допомогою певного перерахованого типу.</p>
<p>Цей спосіб опису використовує ім’я типу перерахування (яке іноді зивають тегом (ярликом) перерахування), яке посилається на раніше описаний тип і використовує його список перерахування, наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">day</span> <span class="p">{</span> <span class="n">saturday</span><span class="p">,</span> <span class="n">sunday</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">monday</span><span class="p">,</span> <span class="n">tuesday</span><span class="p">,</span> <span class="n">wednesday</span><span class="p">,</span> <span class="n">thursday</span><span class="p">,</span> <span class="n">friday</span> <span class="p">}</span> <span class="n">workday</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">day</span> <span class="n">nextday</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">day</span> <span class="n">today</span> <span class="o">=</span> <span class="n">monday</span><span class="p">;</span>
<span class="n">day</span> <span class="n">vacancy</span><span class="p">;</span>
</pre></div>
</div>
<p>У першому випадку визначено тип перерахування <code class="docutils literal notranslate"><span class="pre">day</span></code>, оголошено змінну перерахування <code class="docutils literal notranslate"><span class="pre">workday</span></code>. Іменовані константи одержують такі значення: <code class="docutils literal notranslate"><span class="pre">saturday</span></code> — 0 (за замовчуванням), <code class="docutils literal notranslate"><span class="pre">sunday</span></code> — 0 (явно), інші імена отримують значення від 1 до 5.</p>
<p>У другому випадку оголошено змінну <code class="docutils literal notranslate"><span class="pre">nextday</span></code> типу <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">day</span></code>. Оскільки тип <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">day</span></code> було оголошено раніше, то достатньо лише на нього послатися. У третьому випадку оголошено змінну <code class="docutils literal notranslate"><span class="pre">today</span></code> типу <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">day</span></code>, і її ініціалізовано значенням <code class="docutils literal notranslate"><span class="pre">monday</span></code> зі списку значень.</p>
<p>Можна оголошувати й масиви перерахованого типу, наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">day</span> <span class="n">week</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
</pre></div>
</div>
<p>Зі змінними перераховуваного типу можна проводити такі операції:</p>
<ul class="simple">
<li><p>присвоїти змінну типу enum іншій змінній того ж типу;</p></li>
<li><p>провести порівняння на рівність або нерівність;</p></li>
<li><p>арифметичні операції з константами типу <code class="docutils literal notranslate"><span class="pre">enum(i</span> <span class="pre">=</span> <span class="pre">win</span> <span class="pre">+</span> <span class="pre">aut)</span></code>.</p></li>
</ul>
<p>Не можна до змінних типу <code class="docutils literal notranslate"><span class="pre">enum</span></code> використовувати арифметичні операції та операції <code class="docutils literal notranslate"><span class="pre">++</span></code> і <code class="docutils literal notranslate"><span class="pre">--</span></code>.</p>
<p>Основна причина використання перераховуваного типу — поліпшення читовності програм.</p>
</div>
<div class="section" id="id6">
<h2>Перейменування типів<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Мова С дає змогу дати нову назву вже існуючому типу даних. Для цього використовують ключове слово <code class="docutils literal notranslate"><span class="pre">typedef</span></code>. При цьому створюється новий тип даних. Наприклад:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="kt">char</span> <span class="n">SYMBOL</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">UNSIGN</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">float</span> <span class="n">real</span><span class="p">;</span>
</pre></div>
</div>
<p>Досить часто використовують оператор <code class="docutils literal notranslate"><span class="pre">typedef</span></code> із застосуванням структур:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">st_tag</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">group</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">scholarship</span><span class="p">;</span>
<span class="p">}</span> <span class="n">STUDENT</span><span class="p">;</span>
</pre></div>
</div>
<p>Тепер для визначення змінної можна використовувати як <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">st_tag</span> <span class="pre">avar</span></code>, так і <code class="docutils literal notranslate"><span class="pre">STUDENT</span> <span class="pre">avar</span></code>.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content/lab5"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="intro.html" title="previous page">Вступ</a>
    <a class='right-next' id="next-link" href="questions.html" title="next page">Контрольні питання</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Громова В.В.<br/>
        
            &copy; Copyright 2020.<br/>
          <div class="extra_footer">
            This page was created by <a href="https://github.com/gasperpaul/c-labs-book/graphs/contributors">сommunity</a>.
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../../_static/js/index.js"></script>
    
  </body>
</html>